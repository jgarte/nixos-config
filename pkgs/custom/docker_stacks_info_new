#!/usr/bin/env python
import os
import subprocess
import random

# import dmenu

endpoint_nodes = ["router", "elk1", "tech1", "tech2"] # TODO: provide from nix
nodes_meta = {}

while True:
    entry_node = random.choice(endpoint_nodes)
    swarm_nodes_task = subprocess.Popen('ssh {0} "docker node ls"'.format(entry_node),
                                        shell=True, stdout=subprocess.PIPE)
    nodes_lines = swarm_nodes_task.stdout.read().decode().split("\n")
    task_result = swarm_nodes_task.wait()

    if task_result != 0:
        continue

    for node in nodes_lines[1:-1]:
        node_fields = node.split()
        parts_count = len(node_fields)
        if parts_count == 5:
            nodes_meta[node_fields[1]] = {
                "manager_status": "",
                "status": node_fields[2],
                "availability": node_fields[3]
            }
        elif parts_count == 6:
            nodes_meta[node_fields[1]] = {
                "manager_status": node_fields[4],
                "status": node_fields[2],
                "availability": node_fields[3]
            }
        elif parts_count == 7:
            nodes_meta[node_fields[2]] = {
                "manager_status": node_fields[5],
                "status": node_fields[3],
                "availability": node_fields[4]
            }
    print(nodes_meta)
    break




# ssh

# books_task = subprocess.Popen("fd --full-path /home/alex3rd/bookshelf -e pdf -e djvu",
#                               shell=True, stdout=subprocess.PIPE)
# books.extend([book for book in books_task.stdout.read().decode().split("\n")])
# assert books_task.wait() == 0

# result = dmenu.show(books, prompt='book', lines=30)
# if result:
#     os.system("zathura {0}".format(result))


# { bash, config, dunst, eternal-terminal, gawk, lib, openssh, pkgs, rofi, systemd, tmux, yad, ... }:
# # TODO: think of decoupling from job infra
# with import ../secrets/const.nix { inherit lib config pkgs; };
# let
#   useDockerStackPsCustomFormat = false;
#   docker.stacks.showOnlyRunning = true;
# in ''
#   #!${bash}/bin/bash

#   ${enforce_job_vpn_impl}

#   enforce_job_vpn

#   SWARM_NODES=(
#   ${builtins.concatStringsSep "\n"
#   (map (host: builtins.head host.hostNames) (builtins.filter (host: host.swarm == true) jobExtraHosts))}
#   )
#   SWARM_LEADER_NODE=$(${openssh}/bin/ssh ${jobInfraSeedHost} "docker node ls --format '{{.Hostname}} {{ .ManagerStatus }}' | grep Leader | cut -f1 -d\ ")

#   docker_stack_ps_params() {
#       echo ${if docker.stacks.showOnlyRunning then ''--filter \"desired-state=Running\"'' else ""}
#            ${if useDockerStackPsCustomFormat then " --format \\\"${docker.stacks.psCustomFormat}\\\"" else ""}
#   }

#   MODES=(
#     "status"
#     "logs"
#   )

#   ask_for_mode() {
#       for i in "''${MODES[@]}"
#       do
#           echo "$i"
#       done
#   }

#   ask_for_stack() {
#       STACKS=$(${openssh}/bin/ssh $SWARM_LEADER_NODE \
#                                        "docker stack ls | awk '{if(NR>1)print $1}'" | \
#                                        ${gawk}/bin/awk '{print $1}')
#       for i in "''${STACKS[@]}"
#       do
#           echo "$i"
#       done
#   }

#   show_stack_status() {
#       STACK=$1
#       ${openssh}/bin/ssh $SWARM_LEADER_NODE \
#       "docker stack ps $STACK $(docker_stack_ps_params)" > /tmp/docker_stack_status
#       ${yad}/bin/yad --filename /tmp/docker_stack_status --text-info
#       rm /tmp/docker_stack_status
#   }

#   ask_for_stack_task() {
#       STACK=$1
#       TASKS=$(${openssh}/bin/ssh $SWARM_LEADER_NODE \
#       "docker stack ps $STACK $(docker_stack_ps_params)" | awk '{if(NR>1)print $0}')
#       SERVICE=$(${openssh}/bin/ssh $SWARM_LEADER_NODE \
#       "docker service ls --format='{{.Name}}' | grep $STACK ")
#       TASKS="''${SERVICE}
#   ''${TASKS}"
#       for i in "''${TASKS[@]}"
#       do
#           echo "$i"
#       done
#   }

#   main() {
#       MODE=$( (ask_for_mode) | ${rofi}/bin/rofi -dmenu -p "Mode" )
#       STACK=$( (ask_for_stack) | ${rofi}/bin/rofi -dmenu -p "Stack" )
#       case "$MODE" in
#           status)
#               show_stack_status $STACK
#               ;;
#           logs)
#               TASK=$( (ask_for_stack_task $STACK) | ${rofi}/bin/rofi -dmenu -p "Task" | ${gawk}/bin/awk '{print $1}' )
#               ${tmux}/bin/tmux new-window "${eternal-terminal}/bin/et \
#                                                 $SWARM_LEADER_NODE \
#                                                 -c 'docker service logs --follow $TASK'"
#               ;;
#           *)
#               echo "Unknown mode: $MODE"
#               exit 1
#               ;;
#       esac
#   }

#   main

#   exit 0
# ''
